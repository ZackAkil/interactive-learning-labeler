<html>

<head>

    <style>
        img {
            height: 500px
        }

        canvas {
            border: red solid 2px;
            height: 500px;
            width: 500px;
            image-rendering: pixelated;
        }
    </style>


    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
</head>



<body>

    <img id="image" src="test_image.png">

    <canvas id="canvas" height="500" width="500"></canvas>
    <canvas id="kernal_canvas" height="50" width="50"></canvas>
    <canvas id="output_canvas" height="10" width="10"></canvas>


    <button onclick="create_image_matrix()">create matrix plane </button>

    <br>





    <script>

        function sleep(milliseconds) {
            var start = new Date().getTime();
            for (var i = 0; i < 1e7; i++) {
                if ((new Date().getTime() - start) > milliseconds) {
                    break;
                }
            }
        }


        var model
        var test_input
        var model_shape

        var base_vector

        tf.loadGraphModel("https://tfhub.dev/google/tfjs-model/imagenet/mobilenet_v1_025_128/feature_vector/1/default/1", {
            fromTFHub: true
        }).then(function (m) {
            console.log('loaded model')
            model = m
            model_shape = model.inputs[0].shape
            console.log('model input shape', model_shape)
            test_input = tf.randomNormal([1, model_shape[1], model_shape[2], model_shape[3]])
        })

        // render image to canvas
        var c = document.getElementById("canvas");


        async function render_kernal_image(image_data) {
            var kernal_canvas = document.getElementById("kernal_canvas")
            var kernal_ctx = kernal_canvas.getContext("2d")
            kernal_ctx.clearRect(0, 0, kernal_ctx.width, kernal_ctx.height)
            kernal_ctx.putImageData(image_data, 0, 0)
            kernal_ctx.stroke()


            var img = new Image(); 
            img.src = kernal_canvas.toDataURL(); 
            document.body.appendChild(img)
            

        }


        c.addEventListener('click', (e) => {
            console.log(e, e.offsetX, e.offsetY)



            var kernal_image = ctx.getImageData(e.offsetX - 25, e.offsetY - 25, 50, 50)

            
            
            render_kernal_image(kernal_image)

            console.log(kernal_image)



            base_vector = model.predict(
                tf.image.resizeBilinear(
                    tf.browser.fromPixels(kernal_canvas),
                    [model_shape[1], model_shape[2]]
                ).expandDims()
            )
        })


        var ctx = c.getContext("2d");
        var img = document.getElementById("image");
        // img.crossOrigin = "Anonymous";
        ctx.drawImage(img, 0, 0, c.height, c.width);

        function create_image_matrix() {

            // create matrix of images
            const canvas_shape = [500, 500]
            const frame_shape = [50, 50]
            const stride = 50


            const image_columns = parseInt(canvas_shape[0] / stride)
            const image_rows = parseInt(canvas_shape[1] / stride)

            const total_frames = image_columns * image_rows

            // const frames_buffer = tf.buffer([total_frames, ...frame_shape, 3])

            // const frames = tf.zeros([total_frames, ...frame_shape, 3])

            // console.log('frames shape', frames_buffer.shape)

            var _prev = tf.zeros([50, 50, 3])
            var tensors = []
            for (let i = 0; i < image_columns; i++) {

                for (let j = 0; j < image_rows; j++) {

                    const data = ctx.getImageData(j * stride, i * stride, ...frame_shape)



                    render_kernal_image(data)

                    // sleep(50)


                    const frame_tensor = tf.browser.fromPixels(data)
                    tensors.push(frame_tensor)
                    // confirm that all frames ar different
                    console.log(tf.losses.absoluteDifference(frame_tensor, _prev).dataSync())
                    console.log('simgle fraem check sum', frame_tensor.sum().dataSync())

                    // frames_buffer.set(frame_tensor, count,  )

                    _prev = frame_tensor
                    // count++
                }

            }


            const frames = tf.stack(tensors)
            const output_tensor = tf.image.resizeBilinear(frames, [model_shape[1], model_shape[2]])
            // const output_tensor = tf.image.resizeBilinear(frames_buffer.toTensor(), [model_shape[1], model_shape[2]] )

            // console.log('frames bufer', frames_buffer.toTensor().sum().dataSync())
            console.log('ot check sum', output_tensor.sum().dataSync())
            const image_input_data = output_tensor.dataSync()
            console.log('see first 2 input image data')
            console.log(image_input_data.slice(0, 100))
            console.log(image_input_data.slice(256 * 256 * 3, (256 * 256 * 3) + 100))



            const comparision_vector = base_vector    //tf.ones([256])

            console.log('comp vector', comparision_vector.dataSync())

            const prediction = model.predict(output_tensor)

            console.log('pred', prediction.dataSync())


            // const loss = tf.losses.cosineDistance(comparision_vector.broadcastTo([100,256]), prediction, axis=0, reduction=null) 
            // console.log('loss', loss.dataSync())


            // console.log('quick loss', tf.losses.absoluteDifference(prediction, ))

            // // perform similarity map calucaltion


            function vector_similarity_score(truth_vector, vectors) {

                // MAE
                // return vectors.sub(truth_vector).abs().mean(axis = 1)

                // cosine
                // const dot_product = tf.dot(vectors, truth_vector.reshape([256]) )
                // console.log(dot_product.dataSync())
                // const abs_product =  (prediction.abs().sum(axis=1)).mul( comparision_vector.abs().sum())
                // const cosine_distance = dot_product.div(abs_product)
                // console.log('cos dist', cosine_distance.dataSync())
                // return cosine_distance

                // const cosine_distance =tf.losses.cosineDistance(tf.broadcastTo (truth_vector, [100,256]) , vectors)
                // console.log('cos dist', cosine_distance.dataSync())
                // return cosine_distance



                // cosine
                const dot_product = tf.dot(vectors, truth_vector.reshape([256]))

                const x_length = tf.euclideanNorm(vectors, axis = 1)
                const y_length = truth_vector.euclideanNorm()
                console.log(dot_product.shape, x_length.shape, y_length.shape)
                const cosine_distance = dot_product.div((x_length.mul(y_length)))
                // console.log(dot_product.dataSync())
                // const abs_product =  (prediction.abs().sum(axis=1)).mul( comparision_vector.abs().sum())
                // const cosine_distance = dot_product.div(abs_product)
                console.log('cos dist', cosine_distance.dataSync())
                return cosine_distance




            }

            console.log('prediction 1', prediction.dataSync().slice(0, 30))
            console.log('prediction 2', prediction.dataSync().slice(256, 256 + 30))



            const similarty_score = vector_similarity_score(comparision_vector, prediction)


            const similarity_map = similarty_score.reshape([image_columns, image_rows])



            function draw_similarity_map(sim_map) {

                var c2 = document.getElementById("output_canvas");
                var ctx2 = c2.getContext("2d");

                var new_image = ctx2.createImageData(10, 10); // only do this once per page
                var image_data = new_image.data;
                for (let index = 0; index < 100; index++) {

                    const offset = index * 4

                    image_data[offset] = sim_map[index] * 255;
                    image_data[offset + 1] = sim_map[index] * 255;
                    image_data[offset + 2] = sim_map[index] * 255;
                    image_data[offset + 3] = 255;
                }
                // var d = id.data;

                console.log(new_image)

                ctx2.putImageData(new_image, 0, 0);

                return output_tensor

            }

            draw_similarity_map(similarity_map.dataSync())
        }






        // imput shape = [-1, 299, 299, 3]
    </script>

</body>

</html>